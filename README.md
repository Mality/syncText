## Понедельник 16.12

### В классе

Скачайте скелет проекта и запустите его. Вам нужно запустить сервер -- `python3.7 server.py` --
и браузер -- `http://localhost:5000`.

Для ознакомления с JS сделайте упражнение 1 в `templates/index.html`: напишите выбор уникального имени пользователя. См. [Math.random()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/random).

Далее можете ознакомиться с реализацией серверной части. Для этого попробуйте последовательно менять точку подключения браузера с `/ws1` до `/ws3` в index.html.

Далее, сделайте упражнение 2: измените код хендлера `/ws3`, чтобы он распространял сообщения, полученные от одного пользователя (браузера) до всех остальных. Подсказка: заведите для этого множество очередей всех пользователей.

Как понять, что упражнение выполнено верно?
- в браузере 1 открываем страницу; в странице вычисляется имя "кошка", отправляется на сервер, страница 1 получает от сервера "кошка", и в браузере печатается "кошка";
- в браузере 2 открываем страницу, в странице вычисляется имя "собака", отправляется на сервер, страница 1 получает от сервера "собака", страница 2 получает от сервера "собака", и на странице 1 рисуется "кошка, собака", на странице 2 рисуется "собака".

Наконец, приступайте к упражнению 3: раскомментируйте в `templates/index.html` код кнопки счетчика -- и реализуйте механизм синхронизации!

Подсказки:
- можно использовать структуру данных [Set](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set) для моделирования множества, или можно использовать [Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array) для моделирования множества поверх массива;
- при отправке структурированных данных используйте метод [JSON.stringify](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) для превращения JS-объектов в JSON;
    - обратите внимание, что `Set` просто так в JSON не превращается: это сложный объект;
    - чтобы сериализовать множество в список используйте сниппет `var a = []; s.forEach(function(x) { a.push(x); }); JSON.stringify(a);`;
- при получении используйте [JSON.parse](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) для превращения JSON в JS-объект;
- печатайте объекты в консоль браузера "как есть" через [console.log](https://developer.mozilla.org/ru/docs/Web/API/Console/log);

Полезные ссылки:
* [Visual Studio Code](https://code.visualstudio.com/)
* [Python 3.7+](https://www.python.org/downloads/windows/)
* [Quart](https://pgjones.gitlab.io/quart/index.html) (`pip3 install -U quart`)
* [Bootstrap](https://getbootstrap.com/)
* [jQuery](https://api.jquery.com/)

### Домашнее задание

Во-первых, довести классную работу до рабочего состояния: реализовать счетчик с операцией инкремента.

Во-вторых, добавить операцию *декремента*: теперь счетчик можно и уменьшать, и увеличивать!

Для верстки двух кнопок можно использовать следующий фрагмент кода:
```html
<div class="counter">
    <p id="counter-value" class="lead"></p>
    <div class="btn-group">
        <button id="counter-dec-button" type="button" class="btn btn-danger">Минус</button>
        <button id="counter-inc-button" type="button" class="btn btn-success">Плюс</button>
    </div>
</div>
```

Не забудьте правильным образом подправить id-шники кнопок в JS-коде!

## Вторник 17.12

Реализуем функцию расчета списка правок, который соответствует расчету расстояния Левенштейна:

```js
function editList(left, right) {
    // Необходимо посчитать расстояние Левенштейна между строками left и right
    // И вернуть "список правок", как получить из левой строки правую.
    // На входе -- две строки.
    // На выходе -- массив правок вида:
    // [
    //   ["I", 0, "a"], // вставка
    //   ["D", 3],      // удаление
    //   ["X", 4, "b"], // замена
    // ]
    // Пример:
    //   editList("cat", "cats") = [ ["I", 3, "s"] ]
    //   editList("cat", "cuts") = [ ["X", 1, "u"], ["I", 3, "s"] ]
    //   editList("cat", "at")   = [ ["D", 0 ] ]
    //   editList("", "hi")      = [ ["I", 0, "h"], ["I", 1, "i"] ]
    // Подсказки:
    //   для ассоциативной структуры данных можно использовать JS-массивы:
    //   var a = {}; a[5] = 0;
    //   при этом элементы, к которым не было обращений -- не инициализированы!
    //   var a = {}; a[8] === undefined;
    //   проверка может быть устроена так:
    //   var a = {}; if (a[8] === undefined) { нет ключа } else { есть ключ }
}
```

Реализуем модель документа.

```js
// Документ (строку) будем моделировать как пару множеств:
//
//   D1 = { (position, symbol) } -- множество пар позиция+символ
//   D2 = { position } -- множество удаленных позиций
//
// Адресация в документе будет строиться по индексам и по позициям.
// Индекс -- число -- в классическом понимании идентифицирует символ в строке.
// Индекс меняется от 0 до длины строки без одного.
// Позиция -- путь в дереве аллоцированных позиция от корня до листа.
// Позиция кодируется списком индексов потомков на пути от корня до листа.
//
// Пусть A -- арность каждого узла в дереве, например 100.
//
//   [0] -- начало строки.
//   [100] -- конец строки (A).
//   [0,14] -- идем к "началу строки", далее к 14-му потомку.
//   [82,11] -- идем к потомку под номером 82, далее к 11-му потомку.
//
// === Публичный интерфейс.
//
// Создать новый пустой документ.
function public_newDocument() {
    return {
        foo: "...",
        bar: "..."
    };
}

// Вернуть содержимое документа.
//
// Если документ представлен как множество пар (позиция, символ) плюс множество удаленных позиций,
// то нужно проитерироваться по всем неудаленным позициям в возрастающем порядке и склеить символы.
function public_getContent(document) {
    // TODO: Напиши меня!
}

// Функция, которая возвращает сериализованное состояние.
function public_serializeState(document) {
    // TODO: Напиши меня!
}

// Функция, которая обновляет состояние документа с новым сериализованным состоянием.
function public_mergeStateWith(document, serializedState) {
    // TODO: Напиши меня!
}

// Функция, которая моделирует добавление символа по индексу.
function public_insertAfter(document, index, symbol) {
    p = _getPositionByIndex(document, index);
    q = _getPositionByIndex(document, index + 1);
    z = _allocate(document, p, q);
    _applyInsert(document, z, symbol);
}

// Функция, которая моделирует удаление символа по индексу.
function public_remove(document, index) {
    p = _getPositionByIndex(document, index);
    _applyRemove(document, index);
}

// Функция, которая моделирует замену символа по индексу.
function public_replace(document, index, symbol) {
    public_remove(document, index);
    public_insertAfter(document, index - 1, symbol);
}

// === Приватный интерфейс.
//
// Нам важно уметь преобразовывать индексы в позиции и наоборот.
//
// Реализовать функцию, вычисляющую позицию символа по индексу.
//
// Если index находится в диапазоне [0; N-1] (N -- длина строки),
// то возвращаемая позиция кодирует некоторый узел в дереве.
// Если index равен -1 -- начало строки -- то возвращаемая позиция должна быть [0].
// Если index равен N -- конец строки -- то возвращаемая позиция должна быть [100].
function _getPositionByIndex(document, index) {
    // TODO: Напиши меня!
}

// Реализовать функцию, аллоцирующую новую позицию между двумя границами.
//
// Стратегии аллокации между двумя вершинами могут быть разные.
// Важно аллоцировать не слишком "плотно" новые идентификаторы,
// чтобы обслуживать будущие аллокации без изменения структуры дерева.
//
// Можно следовать стратегии "аллоцировать ближе к левому краю".
// Для этого берем позицию begin и на самом глубоком уровне этой позиции
// пробуем сдвинуться на K направо (K ~ 10-20), чтобы оставить "буфер"
// под будущие правки.
// Если на текущем уровне есть свободные позиции в ближайших K позициях справа,
// то возвращаем крайнюю правую свободную позицию.
// Если на текущем уровне уже нет места, то создаем новый подуровень.
// Важно не забыть проверить, что _нету_ других позиций между begin и свежеаллоцированной позицией.
//
// Такая стратегия оставляет чуть-чуть места для правок между новой позицией и begin,
// и оставляет много места для правок после новой позиции.
// Таким образом, эта стратегия подходит хорошо для ситуаций, когда мы дописываем новый текст.
//
// Пример (здесь "<" значит "предшествует"; K = 10):
//   begin = [4, 52]
//   если позиции с [4, 52] до [4, 62] свободны, то
//   можно аллоцировать [4, 62], так как [4, 52] < [4, 62];
//   begin = [8, 93]
//   можно аллоцировать [8, 93, 10], так как [8, 93] < [8, 93, 10];
//
// Можно следовать стратегии "аллоцировать ближе к правому краю".
// Логика схожая, только отталкиваемся от end и шагаем влево.
// Такая стратегия будет походить для небольших правок в середине текста.
//
// Пример (здесь "<" значит "предшествует"; K = 10):
//   end = [8, 90]
//   если позиции с [8, 80] до [8, 90] свободны, то
//   можно аллоцировать [8, 80];
//   end = [8, 90]
//   если позиция [8, 89] занята,
//   то можно аллоцировать [8, 89, 90];
//
// Лучше всего -- подбрасывать монетку и выбирать случайно одну из двух стратегий выше.
// Таким образом мы будем маскировать незнание паттерна правок в документе.
function _allocate(document, begin, end) {
    if (Math.random() < 0.5) {
        return _allocateLeft(document, begin, end);
    } else {
        return _allocateRight(document, begin, end);
    }
}

function _allocateLeft(document, begin, end) {
    // TODO: Напиши меня!
}

function _allocateRight(document, begin, end) {
    // TODO: Напиши меня!
}

// Применяем операцию добавления символа symbol в позицию (не индекс!) position.
function _applyInsert(document, position, symbol) {
    // нужно обновить D1, сохранив нужную пару
}

// Применяем операцию удаления символа в позиции position.
function _applyRemove(document, position) {
    // нужно обновить D2, сохранив удаленную позицию
}
```