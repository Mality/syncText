//------------------------------------------------
// !!!!! vvvvv vvvvv vvvvv vvvvv vvvvv vvvvv vvvvv
//
// TODO(sandello): Модель документа.
//
// Документ (строку) будем моделировать как пару множеств:
//
//   D1 = { (position, symbol) } -- множество пар (позиция, символ);
//   D2 = { position } -- множество удаленных позиций.
//
// Адресация в документе будет строиться по индексам и по позициям.
//
// Индекс -- число -- в классическом понимании идентифицирует символ в строке.
// Индекс меняется от 0 до длины документа минус один.
//
// Позиция -- путь в дереве аллоцированных позиций от корня до листа.
// Позиция кодируется списком индексов потомков на пути от корня до листа.
//
// Пусть A -- арность каждого узла в дереве, например 100. Тогда:
//
//   [0] -- начало строки.
//   [100] -- конец строки (A).
//   [0,14] -- идем к "началу строки", далее к 14-му потомку.
//   [82,11] -- идем к потомку под номером 82, далее к 11-му потомку.

// === Публичный интерфейс.

// Конструктор.
//
// Инициализирует необходимые структуры данных.
// Результат работы конструктора передается далее во все функции первым аргументом.
function public_newDocument() {
    // TODO: Напиши меня!
    return {
        foo: "...",
        bar: 123,
    };
}

// Вернуть содержимое документа в виде строки.
//
// Так как документ представлен как множество пар (позиция, символ) плюс множество удаленных позиций,
// то нужно проитерироваться по всем неудаленным позициям в возрастающем порядке и склеить символы.
function public_getContent(document) {
    // TODO: Напиши меня!
}

// Вернуть сериализованное состояние.
//
// Эту функцию можно реализовывать ближе к концу, когда основная функциональность будет готова.
//
// Сериализованное состояние передается далее по сети другим пользователям.
function public_serializeState(document) {
    // TODO: Напиши меня!
}

// Обновить состояние документа, подклеив полученное сериализованное состояние.
//
// Эту функцию можно реализовывать ближе к концу, когда основная функциональность будет готова.
function public_mergeWithSerializedState(document, serializedState) {
    // TODO: Напиши меня!
}

// Добавить один символ по индексу.
//
// Начало строки задается индексом -1.
// После конца строки вставлять нельзя.
// Для вставки в конец строки нужно передать индекс последнего символа (длина минус один).
//
// Реализацию данного метода трогать нельзя.
function public_insertAfter(document, index, symbol) {
    p = _getPositionByIndex(document, index);
    q = _getPositionByIndex(document, index + 1);
    z = _allocate(document, p, q);
    _applyInsert(document, z, symbol);
}

// Удалить символ по индексу.
//
// Реализацию данного метода трогать нельзя.
function public_remove(document, index) {
    p = _getPositionByIndex(document, index);
    _applyRemove(document, index);
}

// Заменить символ по индексу.
//
// Реализацию данного метода трогать нельзя.
function public_replace(document, index, symbol) {
    public_remove(document, index);
    public_insertAfter(document, index - 1, symbol);
}

// === Приватный интерфейс.

// Вычислить позицию символа по его индексу.
//
// Нам важно уметь преобразовывать индексы в позиции и наоборот.
//
// Если index находится в диапазоне [0; N-1] (N -- длина строки),
// то возвращаемая позиция кодирует некоторый узел в дереве.
// Если index равен -1 -- начало строки -- то возвращаемая позиция должна быть [0].
// Если index равен N -- конец строки -- то возвращаемая позиция должна быть [100].
function _getPositionByIndex(document, index) {
    // TODO: Напиши меня!
}

// Аллоцировать новую позицию между двумя границами.
//
// Стратегии аллокации между двумя вершинами могут быть разные.
// Важно аллоцировать не слишком "плотно" новые идентификаторы,
// чтобы обслуживать будущие аллокации без изменения структуры дерева.
//
// Можно следовать стратегии "аллоцировать ближе к левому краю".
// Для этого берем позицию begin и на самом глубоком уровне этой позиции
// пробуем сдвинуться на K направо (K ~ 10-20), чтобы оставить "буфер"
// под будущие правки.
// Если на текущем уровне есть свободные позиции в ближайших K позициях справа,
// то возвращаем крайнюю правую свободную позицию.
// Если на текущем уровне уже нет места, то создаем новый подуровень.
// Важно не забыть проверить, что _нету_ других позиций между begin и свежеаллоцированной позицией.
//
// Такая стратегия оставляет чуть-чуть места для правок между новой позицией и begin,
// и оставляет много места для правок после новой позиции.
// Таким образом, эта стратегия подходит хорошо для ситуаций, когда мы дописываем новый текст.
//
// Пример (здесь "<" значит "предшествует"; K = 10):
//   begin = [4, 52]
//   если позиции с [4, 52] до [4, 62] свободны, то
//   можно аллоцировать [4, 62], так как [4, 52] < [4, 62];
//   begin = [8, 93]
//   можно аллоцировать [8, 93, 10], так как [8, 93] < [8, 93, 10];
//
// Можно следовать стратегии "аллоцировать ближе к правому краю".
// Логика схожая, только отталкиваемся от end и шагаем влево.
// Такая стратегия будет походить для небольших правок в середине текста.
//
// Пример (здесь "<" значит "предшествует"; K = 10):
//   end = [8, 90]
//   если позиции с [8, 80] до [8, 90] свободны, то
//   можно аллоцировать [8, 80];
//   end = [8, 90]
//   если позиция [8, 89] занята,
//   то можно аллоцировать [8, 89, 90];
//
// Лучше всего -- подбрасывать монетку и выбирать случайно одну из двух стратегий выше.
// Таким образом мы будем маскировать незнание паттерна правок в документе.
function _allocate(document, begin, end) {
    if (Math.random() < 0.5) {
        return _allocateLeft(document, begin, end);
    } else {
        return _allocateRight(document, begin, end);
    }
}

function _allocateLeft(document, begin, end) {
    // TODO: Напиши меня!
}

function _allocateRight(document, begin, end) {
    // TODO: Напиши меня!
}

// Вставить символ в указанную позицию (не индекс!).
function _applyInsert(document, position, symbol) {
    // TODO: Напиши меня!
}

// Удалить символ в указанной позиции.
function _applyRemove(document, position) {
    // TODO: Напиши меня!
}

// !!!!! ^^^^^ ^^^^^ ^^^^^ ^^^^^ ^^^^^ ^^^^^ ^^^^^
//------------------------------------------------
